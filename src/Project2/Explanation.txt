Για να βρούμε το Maximum Subarray Sum από ένα array θα μπορούσαμε να κάνουμε ένα
nested loop και να παίρνουμε τα currentSum και να τα συγκρίνουμε με το τελικό sum
και να το κάνουμε update όταν χρειάζεται αλλά αυτός ο τρόπος έχει time complexity
O(n^2) και δεν θεώρείται optimal. Για να περάσουμε το Array μόνο μία φορά χρειαζόμαστε
κάτι σαν base case, όπου κάποια στοιχεία θεωρούνται θετικά σε σχέση με αυτό και κάποια
αρνητικά. Προφανώς αφού ψάχνουμε το μεγαλύτερο άθροισμα, όλοι οι θετικοί συνισφέρουν
σε αυτό το sum και οι αρνητικοί αριθμοί το μειώνουν. Ξεκινάμε να προσθέτουμε όλους τους
αριθμούς απ΄την αρχή και όταν δούμε οτι το sum που έχουμε μαζέψει μέχρι στιγμής είναι
αρνητικό τότε "κόβουμε" το array που κάνουμε iterate σε subarrays, μηδενίζουμε το sum
και ξεκινάμε να μετράμε απ'την αρχή ένα καινούργιο sum. Έτσι το αρχικό array to κόβουμε
σε επί μέρους κομμάτια και καθόλη την διαδικασία αυτή, τσεκάρουμε το currSum με το maxSum
και το κάνουμε update όταν currSum > maxSum. Αν όλοι οι αριθμοί είναι αρνητικοί στο
αρχικό array τότε επιστρέφουμε ένα στοιχείο στο subArray, τον μεγαλύτερο αρνητικό, αν είναι
όλοι θετικοί τότε επιστρέφουμε όλο το αρχικό array. Αν χρησιμοπιούμε ενα subArray για να
κρατάμε τα στοιχεία και το κάνουμε copy στο finalSubArray μαζί με το currSum copy στο
maxSum τότε η πολυπλοκότητα χρόνου θα ήταν πάλι O(n^2) (το worst case), γι'αυτό κρατάμε
indexes που δείχνουν που αρχίζει και που τελιώνει το κάθε subArray, και όταν τελιώσουμε το
pass φτιάχνουμε αυτό το array με τα τελικά indexes και τον επιστρέφουμε.